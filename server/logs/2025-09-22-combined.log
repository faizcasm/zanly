{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 5 minutes","timestamp":"2025-09-22T09:46:36.355Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T09:50:00.054Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T09:55:00.031Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T10:00:00.048Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T10:05:00.036Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T10:10:00.035Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T10:15:00.021Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T10:20:00.035Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T10:25:00.034Z"}
{"accessToken":"ya29.a0AQQ_BDTNygxBZRufw7l1HDAZjrWupogG0h5ScKL2XXJf_aYL_OZ5DBr6oWRuDXRnfhkwkJ5fZNzZ-G3tHFtaAE33MYoMvCll_DjNskknLQz81REKy0kMRXuTE2Jce5fIXaov2NtXH9lnpKNLs4zsJTmpBEWVHCM6-85mh3BXfwD1S4ZGhFuoVFhHs2T0g3dJzjiH2U8aCgYKAS4SARQSFQHGX2MiWPUWQXacmJT7uDrcVB8oow0206","email":"faizanhameed690@gmail.com","image":"https://lh3.googleusercontent.com/a/ACg8ocJNezmPuPTLe-fI4xdR_uzi-wv30QIp9iGS65ktXANla_veBZUK=s96-c","level":"info","message":"OAuth login for existing user","name":"Faizan Hameed Tantray","timestamp":"2025-09-22T10:26:47.568Z"}
{"accessToken":"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","email":"udesignfaizcasm@gmail.com","id":"138277686","image":"https://avatars.githubusercontent.com/u/138277686?v=4","level":"info","message":"OAuth login for existing user","name":"Faizan Hameed Tantray","timestamp":"2025-09-22T10:27:00.222Z"}
{"accessToken":"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","email":"udesignfaizcasm@gmail.com","id":"138277686","image":"https://avatars.githubusercontent.com/u/138277686?v=4","level":"info","message":"OAuth login for existing user","name":"Faizan Hameed Tantray","timestamp":"2025-09-22T10:27:16.403Z"}
{"createdAt":"2025-09-22T10:27:51.406Z","email":"udesignfaizcasm@gmail.com","id":17,"image":"https://avatars.githubusercontent.com/u/138277686?v=4","level":"info","message":"OAuth new user created","name":"Faizan Hameed Tantray","otp":null,"otpExpiry":null,"password":null,"publicId":null,"role":"USER","timestamp":"2025-09-22T10:27:51.418Z","updatedAt":"2025-09-22T10:27:51.406Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T10:30:00.052Z"}
{"accessToken":"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","email":"udesignfaizcasm@gmail.com","id":"138277686","image":"https://avatars.githubusercontent.com/u/138277686?v=4","level":"info","message":"OAuth login for existing user","name":"Faizan Hameed Tantray","timestamp":"2025-09-22T10:30:28.495Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T10:35:00.035Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 5 minutes","timestamp":"2025-09-22T11:09:56.955Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T11:10:00.094Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 1 minutes","timestamp":"2025-09-22T11:11:43.776Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T11:12:00.065Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T11:13:00.027Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T11:14:00.037Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T11:15:00.041Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:15:53.056Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:16:32.220Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:16:41.008Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:16:43.343Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:16:46.301Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:16:49.253Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:16:51.720Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:17:02.852Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:18:05.693Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:19:33.275Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:19:39.136Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:19:43.238Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T11:20:00.085Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:20:21.255Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:22:17.445Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:22:22.406Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:22:26.072Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:22:30.823Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:22:36.712Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:23:16.751Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:23:30.139Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:23:35.271Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:23:40.822Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:24:28.471Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:24:33.870Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:24:47.008Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:26:16.019Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:26:19.474Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:27:04.705Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:28:17.334Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:28:23.789Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T11:30:00.088Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:37:33.604Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:39:45.798Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:40:23.162Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:41:50.574Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:41:56.431Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:42:33.707Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:44:36.590Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:44:51.986Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:44:58.406Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:45:02.875Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:45:08.649Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:45:12.044Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:45:18.644Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:45:25.961Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:46:28.910Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:46:32.287Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:46:45.940Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:46:55.283Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:47:02.331Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:47:07.233Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:47:12.433Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:47:15.450Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:47:18.978Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:47:24.934Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:47:31.624Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:47:36.646Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:47:40.909Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:47:45.413Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:47:49.326Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:49:18.857Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:49:22.520Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:49:26.328Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:49:33.362Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:49:37.265Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:49:40.985Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:49:45.482Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:49:51.762Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T11:50:00.886Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:04:09.076Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:04:52.449Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:05:08.410Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:05:53.040Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:05:56.473Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:05:59.998Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:06:09.623Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:06:14.732Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:06:18.721Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:06:31.547Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:06:34.756Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:08:33.343Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:09:00.046Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:09:00.096Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:09:54.049Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:09:54.100Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:09:58.975Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:09:59.029Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:10:01.781Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:10:01.834Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:10:05.450Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:10:05.526Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:10:20.773Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:10:20.815Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:10:27.086Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:10:31.539Z"}
{"level":"info","message":"","timestamp":"2025-09-22T12:10:31.544Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:10:31.582Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:10:45.619Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:10:45.628Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:10:45.688Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:11:02.057Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:11:02.065Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:11:02.128Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:11:16.197Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:11:16.203Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:11:16.255Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:11:16.256Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:11:29.661Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:11:29.670Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:11:29.714Z"}
{"level":"info","message":"Server started at","timestamp":"2025-09-22T12:11:29.715Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:11:31.734Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:11:31.740Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:11:31.802Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:11:31.804Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:11:38.856Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:11:38.869Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:11:38.930Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:11:38.932Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:11:46.648Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:11:46.654Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:11:46.711Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:11:46.713Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:11:46.714Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:12:05.841Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:12:05.847Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:12:05.898Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:12:05.899Z"}
{"level":"info","message":"","timestamp":"2025-09-22T12:12:05.899Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:12:31.158Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:12:31.163Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:12:31.206Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:12:31.207Z"}
{"level":"info","message":"class URL {\r\n  #context = new URLContext();\r\n  #searchParams;\r\n  #searchParamsModified;\r\n\r\n  static {\r\n    setURLSearchParamsModified = (obj) => {\r\n      // When URLSearchParams changes, we lazily update URL on the next read/write for performance.\r\n      obj.#searchParamsModified = true;\r\n\r\n      // If URL has an existing search, remove it without cascading back to URLSearchParams.\r\n      // Do this to avoid any internal confusion about whether URLSearchParams or URL is up-to-date.\r\n      if (obj.#context.hasSearch) {\r\n        obj.#updateContext(bindingUrl.update(obj.#context.href, updateActions.kSearch, ''));\r\n      }\r\n    };\r\n  }\r\n\r\n  constructor(input, base = undefined, parseSymbol = undefined) {\r\n    markTransferMode(this, false, false);\r\n\r\n    if (arguments.length === 0) {\r\n      throw new ERR_MISSING_ARGS('url');\r\n    }\r\n\r\n    // StringPrototypeToWellFormed is not needed.\r\n    input = `${input}`;\r\n\r\n    if (base !== undefined) {\r\n      base = `${base}`;\r\n    }\r\n\r\n    let href;\r\n    if (arguments.length < 3) {\r\n      href = bindingUrl.parse(input, base, true);\r\n    } else {\r\n      const raiseException = parseSymbol !== kParseURLSymbol;\r\n      const interpretAsWindowsPath = parseSymbol === kCreateURLFromWindowsPathSymbol;\r\n      const pathToFileURL = interpretAsWindowsPath || (parseSymbol === kCreateURLFromPosixPathSymbol);\r\n      href = pathToFileURL ?\r\n        bindingUrl.pathToFileURL(input, interpretAsWindowsPath, base) :\r\n        bindingUrl.parse(input, base, raiseException);\r\n    }\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  static parse(input, base = undefined) {\r\n    if (arguments.length === 0) {\r\n      throw new ERR_MISSING_ARGS('url');\r\n    }\r\n    const parsedURLObject = new URL(input, base, kParseURLSymbol);\r\n    return parsedURLObject.href ? parsedURLObject : null;\r\n  }\r\n\r\n  [inspect.custom](depth, opts) {\r\n    if (typeof depth === 'number' && depth < 0)\r\n      return this;\r\n\r\n    const constructor = getConstructorOf(this) || URL;\r\n    const obj = { __proto__: { constructor } };\r\n\r\n    obj.href = this.href;\r\n    obj.origin = this.origin;\r\n    obj.protocol = this.protocol;\r\n    obj.username = this.username;\r\n    obj.password = this.password;\r\n    obj.host = this.host;\r\n    obj.hostname = this.hostname;\r\n    obj.port = this.port;\r\n    obj.pathname = this.pathname;\r\n    obj.search = this.search;\r\n    obj.searchParams = this.searchParams;\r\n    obj.hash = this.hash;\r\n\r\n    if (opts.showHidden) {\r\n      obj[contextForInspect] = this.#context;\r\n    }\r\n\r\n    return `${constructor.name} ${inspect(obj, opts)}`;\r\n  }\r\n\r\n  #getSearchFromContext() {\r\n    if (!this.#context.hasSearch) return '';\r\n    let endsAt = this.#context.href.length;\r\n    if (this.#context.hasHash) endsAt = this.#context.hash_start;\r\n    if (endsAt - this.#context.search_start <= 1) return '';\r\n    return StringPrototypeSlice(this.#context.href, this.#context.search_start, endsAt);\r\n  }\r\n\r\n  #getSearchFromParams() {\r\n    if (!this.#searchParams?.size) return '';\r\n    return `?${this.#searchParams}`;\r\n  }\r\n\r\n  #ensureSearchParamsUpdated() {\r\n    // URL is updated lazily to greatly improve performance when URLSearchParams is updated repeatedly.\r\n    // If URLSearchParams has been modified, reflect that back into URL, without cascading back.\r\n    if (this.#searchParamsModified) {\r\n      this.#searchParamsModified = false;\r\n      this.#updateContext(bindingUrl.update(this.#context.href, updateActions.kSearch, this.#getSearchFromParams()));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the internal context state for URL.\r\n   * @param {string} href New href string from `bindingUrl.update`.\r\n   * @param {boolean} [shouldUpdateSearchParams] If the update has potential to update search params (href/search).\r\n   */\r\n  #updateContext(href, shouldUpdateSearchParams = false) {\r\n    const previousSearch = shouldUpdateSearchParams && this.#searchParams &&\r\n      (this.#searchParamsModified ? this.#getSearchFromParams() : this.#getSearchFromContext());\r\n\r\n    this.#context.href = href;\r\n\r\n    const {\r\n      0: protocol_end,\r\n      1: username_end,\r\n      2: host_start,\r\n      3: host_end,\r\n      4: port,\r\n      5: pathname_start,\r\n      6: search_start,\r\n      7: hash_start,\r\n      8: scheme_type,\r\n    } = bindingUrl.urlComponents;\r\n\r\n    this.#context.protocol_end = protocol_end;\r\n    this.#context.username_end = username_end;\r\n    this.#context.host_start = host_start;\r\n    this.#context.host_end = host_end;\r\n    this.#context.port = port;\r\n    this.#context.pathname_start = pathname_start;\r\n    this.#context.search_start = search_start;\r\n    this.#context.hash_start = hash_start;\r\n    this.#context.scheme_type = scheme_type;\r\n\r\n    if (this.#searchParams) {\r\n      // If the search string has updated, URL becomes the source of truth, and we update URLSearchParams.\r\n      // Only do this when we're expecting it to have changed, otherwise a change to hash etc.\r\n      // would incorrectly compare the URLSearchParams state to the empty URL search state.\r\n      if (shouldUpdateSearchParams) {\r\n        const currentSearch = this.#getSearchFromContext();\r\n        if (previousSearch !== currentSearch) {\r\n          setURLSearchParams(this.#searchParams, currentSearch);\r\n          this.#searchParamsModified = false;\r\n        }\r\n      }\r\n\r\n      // If we have a URLSearchParams, ensure that URL is up-to-date with any modification to it.\r\n      this.#ensureSearchParamsUpdated();\r\n    }\r\n  }\r\n\r\n  toString() {\r\n    // Updates to URLSearchParams are lazily propagated to URL, so we need to check we're in sync.\r\n    this.#ensureSearchParamsUpdated();\r\n    return this.#context.href;\r\n  }\r\n\r\n  get href() {\r\n    // Updates to URLSearchParams are lazily propagated to URL, so we need to check we're in sync.\r\n    this.#ensureSearchParamsUpdated();\r\n    return this.#context.href;\r\n  }\r\n\r\n  set href(value) {\r\n    value = `${value}`;\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kHref, value);\r\n    if (!href) { throw new ERR_INVALID_URL(value); }\r\n    this.#updateContext(href, true);\r\n  }\r\n\r\n  // readonly\r\n  get origin() {\r\n    const protocol = StringPrototypeSlice(this.#context.href, 0, this.#context.protocol_end);\r\n\r\n    // Check if scheme_type is not `NOT_SPECIAL`\r\n    if (this.#context.scheme_type !== 1) {\r\n      // Check if scheme_type is `FILE`\r\n      if (this.#context.scheme_type === 6) {\r\n        return 'null';\r\n      }\r\n      return `${protocol}//${this.host}`;\r\n    }\r\n\r\n    if (protocol === 'blob:') {\r\n      const path = this.pathname;\r\n      if (path.length > 0) {\r\n        try {\r\n          const out = new URL(path);\r\n          // Only return origin of scheme is `http` or `https`\r\n          // Otherwise return a new opaque origin (null).\r\n          if (out.#context.scheme_type === 0 || out.#context.scheme_type === 2) {\r\n            return `${out.protocol}//${out.host}`;\r\n          }\r\n        } catch {\r\n          // Do nothing.\r\n        }\r\n      }\r\n    }\r\n\r\n    return 'null';\r\n  }\r\n\r\n  get protocol() {\r\n    return StringPrototypeSlice(this.#context.href, 0, this.#context.protocol_end);\r\n  }\r\n\r\n  set protocol(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kProtocol, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get username() {\r\n    if (this.#context.protocol_end + 2 < this.#context.username_end) {\r\n      return StringPrototypeSlice(this.#context.href, this.#context.protocol_end + 2, this.#context.username_end);\r\n    }\r\n    return '';\r\n  }\r\n\r\n  set username(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kUsername, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get password() {\r\n    if (this.#context.host_start - this.#context.username_end > 0) {\r\n      return StringPrototypeSlice(this.#context.href, this.#context.username_end + 1, this.#context.host_start);\r\n    }\r\n    return '';\r\n  }\r\n\r\n  set password(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kPassword, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get host() {\r\n    let startsAt = this.#context.host_start;\r\n    if (this.#context.href[startsAt] === '@') {\r\n      startsAt++;\r\n    }\r\n    // If we have an empty host, then the space between components.host_end and\r\n    // components.pathname_start may be occupied by /.\r\n    if (startsAt === this.#context.host_end) {\r\n      return '';\r\n    }\r\n    return StringPrototypeSlice(this.#context.href, startsAt, this.#context.pathname_start);\r\n  }\r\n\r\n  set host(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kHost, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get hostname() {\r\n    let startsAt = this.#context.host_start;\r\n    // host_start might be \"@\" if the URL has credentials\r\n    if (this.#context.href[startsAt] === '@') {\r\n      startsAt++;\r\n    }\r\n    return StringPrototypeSlice(this.#context.href, startsAt, this.#context.host_end);\r\n  }\r\n\r\n  set hostname(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kHostname, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get port() {\r\n    if (this.#context.hasPort) {\r\n      return `${this.#context.port}`;\r\n    }\r\n    return '';\r\n  }\r\n\r\n  set port(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kPort, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get pathname() {\r\n    let endsAt;\r\n    if (this.#context.hasSearch) {\r\n      endsAt = this.#context.search_start;\r\n    } else if (this.#context.hasHash) {\r\n      endsAt = this.#context.hash_start;\r\n    }\r\n    return StringPrototypeSlice(this.#context.href, this.#context.pathname_start, endsAt);\r\n  }\r\n\r\n  set pathname(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kPathname, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get search() {\r\n    // Updates to URLSearchParams are lazily propagated to URL, so we need to check we're in sync.\r\n    this.#ensureSearchParamsUpdated();\r\n    return this.#getSearchFromContext();\r\n  }\r\n\r\n  set search(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kSearch, StringPrototypeToWellFormed(`${value}`));\r\n    if (href) {\r\n      this.#updateContext(href, true);\r\n    }\r\n  }\r\n\r\n  // readonly\r\n  get searchParams() {\r\n    // Create URLSearchParams on demand to greatly improve the URL performance.\r\n    if (this.#searchParams == null) {\r\n      this.#searchParams = new URLSearchParams(this.#getSearchFromContext());\r\n      setURLSearchParamsContext(this.#searchParams, this);\r\n      this.#searchParamsModified = false;\r\n    }\r\n    return this.#searchParams;\r\n  }\r\n\r\n  get hash() {\r\n    if (!this.#context.hasHash || (this.#context.href.length - this.#context.hash_start <= 1)) {\r\n      return '';\r\n    }\r\n    return StringPrototypeSlice(this.#context.href, this.#context.hash_start);\r\n  }\r\n\r\n  set hash(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kHash, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  toJSON() {\r\n    // Updates to URLSearchParams are lazily propagated to URL, so we need to check we're in sync.\r\n    this.#ensureSearchParamsUpdated();\r\n    return this.#context.href;\r\n  }\r\n\r\n  static canParse(url, base = undefined) {\r\n    if (arguments.length === 0) {\r\n      throw new ERR_MISSING_ARGS('url');\r\n    }\r\n\r\n    url = `${url}`;\r\n\r\n    if (base !== undefined) {\r\n      return bindingUrl.canParse(url, `${base}`);\r\n    }\r\n\r\n    // It is important to differentiate the canParse call statements\r\n    // since they resolve into different v8 fast api overloads.\r\n    return bindingUrl.canParse(url);\r\n  }\r\n}","timestamp":"2025-09-22T12:12:31.208Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:12:34.717Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:12:34.723Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:12:34.773Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:12:34.774Z"}
{"level":"info","message":"class URL {\r\n  #context = new URLContext();\r\n  #searchParams;\r\n  #searchParamsModified;\r\n\r\n  static {\r\n    setURLSearchParamsModified = (obj) => {\r\n      // When URLSearchParams changes, we lazily update URL on the next read/write for performance.\r\n      obj.#searchParamsModified = true;\r\n\r\n      // If URL has an existing search, remove it without cascading back to URLSearchParams.\r\n      // Do this to avoid any internal confusion about whether URLSearchParams or URL is up-to-date.\r\n      if (obj.#context.hasSearch) {\r\n        obj.#updateContext(bindingUrl.update(obj.#context.href, updateActions.kSearch, ''));\r\n      }\r\n    };\r\n  }\r\n\r\n  constructor(input, base = undefined, parseSymbol = undefined) {\r\n    markTransferMode(this, false, false);\r\n\r\n    if (arguments.length === 0) {\r\n      throw new ERR_MISSING_ARGS('url');\r\n    }\r\n\r\n    // StringPrototypeToWellFormed is not needed.\r\n    input = `${input}`;\r\n\r\n    if (base !== undefined) {\r\n      base = `${base}`;\r\n    }\r\n\r\n    let href;\r\n    if (arguments.length < 3) {\r\n      href = bindingUrl.parse(input, base, true);\r\n    } else {\r\n      const raiseException = parseSymbol !== kParseURLSymbol;\r\n      const interpretAsWindowsPath = parseSymbol === kCreateURLFromWindowsPathSymbol;\r\n      const pathToFileURL = interpretAsWindowsPath || (parseSymbol === kCreateURLFromPosixPathSymbol);\r\n      href = pathToFileURL ?\r\n        bindingUrl.pathToFileURL(input, interpretAsWindowsPath, base) :\r\n        bindingUrl.parse(input, base, raiseException);\r\n    }\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  static parse(input, base = undefined) {\r\n    if (arguments.length === 0) {\r\n      throw new ERR_MISSING_ARGS('url');\r\n    }\r\n    const parsedURLObject = new URL(input, base, kParseURLSymbol);\r\n    return parsedURLObject.href ? parsedURLObject : null;\r\n  }\r\n\r\n  [inspect.custom](depth, opts) {\r\n    if (typeof depth === 'number' && depth < 0)\r\n      return this;\r\n\r\n    const constructor = getConstructorOf(this) || URL;\r\n    const obj = { __proto__: { constructor } };\r\n\r\n    obj.href = this.href;\r\n    obj.origin = this.origin;\r\n    obj.protocol = this.protocol;\r\n    obj.username = this.username;\r\n    obj.password = this.password;\r\n    obj.host = this.host;\r\n    obj.hostname = this.hostname;\r\n    obj.port = this.port;\r\n    obj.pathname = this.pathname;\r\n    obj.search = this.search;\r\n    obj.searchParams = this.searchParams;\r\n    obj.hash = this.hash;\r\n\r\n    if (opts.showHidden) {\r\n      obj[contextForInspect] = this.#context;\r\n    }\r\n\r\n    return `${constructor.name} ${inspect(obj, opts)}`;\r\n  }\r\n\r\n  #getSearchFromContext() {\r\n    if (!this.#context.hasSearch) return '';\r\n    let endsAt = this.#context.href.length;\r\n    if (this.#context.hasHash) endsAt = this.#context.hash_start;\r\n    if (endsAt - this.#context.search_start <= 1) return '';\r\n    return StringPrototypeSlice(this.#context.href, this.#context.search_start, endsAt);\r\n  }\r\n\r\n  #getSearchFromParams() {\r\n    if (!this.#searchParams?.size) return '';\r\n    return `?${this.#searchParams}`;\r\n  }\r\n\r\n  #ensureSearchParamsUpdated() {\r\n    // URL is updated lazily to greatly improve performance when URLSearchParams is updated repeatedly.\r\n    // If URLSearchParams has been modified, reflect that back into URL, without cascading back.\r\n    if (this.#searchParamsModified) {\r\n      this.#searchParamsModified = false;\r\n      this.#updateContext(bindingUrl.update(this.#context.href, updateActions.kSearch, this.#getSearchFromParams()));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the internal context state for URL.\r\n   * @param {string} href New href string from `bindingUrl.update`.\r\n   * @param {boolean} [shouldUpdateSearchParams] If the update has potential to update search params (href/search).\r\n   */\r\n  #updateContext(href, shouldUpdateSearchParams = false) {\r\n    const previousSearch = shouldUpdateSearchParams && this.#searchParams &&\r\n      (this.#searchParamsModified ? this.#getSearchFromParams() : this.#getSearchFromContext());\r\n\r\n    this.#context.href = href;\r\n\r\n    const {\r\n      0: protocol_end,\r\n      1: username_end,\r\n      2: host_start,\r\n      3: host_end,\r\n      4: port,\r\n      5: pathname_start,\r\n      6: search_start,\r\n      7: hash_start,\r\n      8: scheme_type,\r\n    } = bindingUrl.urlComponents;\r\n\r\n    this.#context.protocol_end = protocol_end;\r\n    this.#context.username_end = username_end;\r\n    this.#context.host_start = host_start;\r\n    this.#context.host_end = host_end;\r\n    this.#context.port = port;\r\n    this.#context.pathname_start = pathname_start;\r\n    this.#context.search_start = search_start;\r\n    this.#context.hash_start = hash_start;\r\n    this.#context.scheme_type = scheme_type;\r\n\r\n    if (this.#searchParams) {\r\n      // If the search string has updated, URL becomes the source of truth, and we update URLSearchParams.\r\n      // Only do this when we're expecting it to have changed, otherwise a change to hash etc.\r\n      // would incorrectly compare the URLSearchParams state to the empty URL search state.\r\n      if (shouldUpdateSearchParams) {\r\n        const currentSearch = this.#getSearchFromContext();\r\n        if (previousSearch !== currentSearch) {\r\n          setURLSearchParams(this.#searchParams, currentSearch);\r\n          this.#searchParamsModified = false;\r\n        }\r\n      }\r\n\r\n      // If we have a URLSearchParams, ensure that URL is up-to-date with any modification to it.\r\n      this.#ensureSearchParamsUpdated();\r\n    }\r\n  }\r\n\r\n  toString() {\r\n    // Updates to URLSearchParams are lazily propagated to URL, so we need to check we're in sync.\r\n    this.#ensureSearchParamsUpdated();\r\n    return this.#context.href;\r\n  }\r\n\r\n  get href() {\r\n    // Updates to URLSearchParams are lazily propagated to URL, so we need to check we're in sync.\r\n    this.#ensureSearchParamsUpdated();\r\n    return this.#context.href;\r\n  }\r\n\r\n  set href(value) {\r\n    value = `${value}`;\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kHref, value);\r\n    if (!href) { throw new ERR_INVALID_URL(value); }\r\n    this.#updateContext(href, true);\r\n  }\r\n\r\n  // readonly\r\n  get origin() {\r\n    const protocol = StringPrototypeSlice(this.#context.href, 0, this.#context.protocol_end);\r\n\r\n    // Check if scheme_type is not `NOT_SPECIAL`\r\n    if (this.#context.scheme_type !== 1) {\r\n      // Check if scheme_type is `FILE`\r\n      if (this.#context.scheme_type === 6) {\r\n        return 'null';\r\n      }\r\n      return `${protocol}//${this.host}`;\r\n    }\r\n\r\n    if (protocol === 'blob:') {\r\n      const path = this.pathname;\r\n      if (path.length > 0) {\r\n        try {\r\n          const out = new URL(path);\r\n          // Only return origin of scheme is `http` or `https`\r\n          // Otherwise return a new opaque origin (null).\r\n          if (out.#context.scheme_type === 0 || out.#context.scheme_type === 2) {\r\n            return `${out.protocol}//${out.host}`;\r\n          }\r\n        } catch {\r\n          // Do nothing.\r\n        }\r\n      }\r\n    }\r\n\r\n    return 'null';\r\n  }\r\n\r\n  get protocol() {\r\n    return StringPrototypeSlice(this.#context.href, 0, this.#context.protocol_end);\r\n  }\r\n\r\n  set protocol(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kProtocol, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get username() {\r\n    if (this.#context.protocol_end + 2 < this.#context.username_end) {\r\n      return StringPrototypeSlice(this.#context.href, this.#context.protocol_end + 2, this.#context.username_end);\r\n    }\r\n    return '';\r\n  }\r\n\r\n  set username(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kUsername, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get password() {\r\n    if (this.#context.host_start - this.#context.username_end > 0) {\r\n      return StringPrototypeSlice(this.#context.href, this.#context.username_end + 1, this.#context.host_start);\r\n    }\r\n    return '';\r\n  }\r\n\r\n  set password(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kPassword, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get host() {\r\n    let startsAt = this.#context.host_start;\r\n    if (this.#context.href[startsAt] === '@') {\r\n      startsAt++;\r\n    }\r\n    // If we have an empty host, then the space between components.host_end and\r\n    // components.pathname_start may be occupied by /.\r\n    if (startsAt === this.#context.host_end) {\r\n      return '';\r\n    }\r\n    return StringPrototypeSlice(this.#context.href, startsAt, this.#context.pathname_start);\r\n  }\r\n\r\n  set host(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kHost, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get hostname() {\r\n    let startsAt = this.#context.host_start;\r\n    // host_start might be \"@\" if the URL has credentials\r\n    if (this.#context.href[startsAt] === '@') {\r\n      startsAt++;\r\n    }\r\n    return StringPrototypeSlice(this.#context.href, startsAt, this.#context.host_end);\r\n  }\r\n\r\n  set hostname(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kHostname, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get port() {\r\n    if (this.#context.hasPort) {\r\n      return `${this.#context.port}`;\r\n    }\r\n    return '';\r\n  }\r\n\r\n  set port(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kPort, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get pathname() {\r\n    let endsAt;\r\n    if (this.#context.hasSearch) {\r\n      endsAt = this.#context.search_start;\r\n    } else if (this.#context.hasHash) {\r\n      endsAt = this.#context.hash_start;\r\n    }\r\n    return StringPrototypeSlice(this.#context.href, this.#context.pathname_start, endsAt);\r\n  }\r\n\r\n  set pathname(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kPathname, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  get search() {\r\n    // Updates to URLSearchParams are lazily propagated to URL, so we need to check we're in sync.\r\n    this.#ensureSearchParamsUpdated();\r\n    return this.#getSearchFromContext();\r\n  }\r\n\r\n  set search(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kSearch, StringPrototypeToWellFormed(`${value}`));\r\n    if (href) {\r\n      this.#updateContext(href, true);\r\n    }\r\n  }\r\n\r\n  // readonly\r\n  get searchParams() {\r\n    // Create URLSearchParams on demand to greatly improve the URL performance.\r\n    if (this.#searchParams == null) {\r\n      this.#searchParams = new URLSearchParams(this.#getSearchFromContext());\r\n      setURLSearchParamsContext(this.#searchParams, this);\r\n      this.#searchParamsModified = false;\r\n    }\r\n    return this.#searchParams;\r\n  }\r\n\r\n  get hash() {\r\n    if (!this.#context.hasHash || (this.#context.href.length - this.#context.hash_start <= 1)) {\r\n      return '';\r\n    }\r\n    return StringPrototypeSlice(this.#context.href, this.#context.hash_start);\r\n  }\r\n\r\n  set hash(value) {\r\n    const href = bindingUrl.update(this.#context.href, updateActions.kHash, `${value}`);\r\n    if (href) {\r\n      this.#updateContext(href);\r\n    }\r\n  }\r\n\r\n  toJSON() {\r\n    // Updates to URLSearchParams are lazily propagated to URL, so we need to check we're in sync.\r\n    this.#ensureSearchParamsUpdated();\r\n    return this.#context.href;\r\n  }\r\n\r\n  static canParse(url, base = undefined) {\r\n    if (arguments.length === 0) {\r\n      throw new ERR_MISSING_ARGS('url');\r\n    }\r\n\r\n    url = `${url}`;\r\n\r\n    if (base !== undefined) {\r\n      return bindingUrl.canParse(url, `${base}`);\r\n    }\r\n\r\n    // It is important to differentiate the canParse call statements\r\n    // since they resolve into different v8 fast api overloads.\r\n    return bindingUrl.canParse(url);\r\n  }\r\n}","timestamp":"2025-09-22T12:12:34.775Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:12:42.879Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:12:42.885Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:12:42.946Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:12:42.948Z"}
{"level":"info","message":"undefined","timestamp":"2025-09-22T12:12:42.949Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:12:51.043Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:12:51.050Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:12:51.101Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:12:51.102Z"}
{"level":"info","message":"undefined","timestamp":"2025-09-22T12:12:51.102Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:12:55.185Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:12:55.196Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:12:55.257Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:12:55.260Z"}
{"level":"info","message":"undefined","timestamp":"2025-09-22T12:12:55.260Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:13:11.798Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:13:11.803Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:13:11.845Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:13:11.847Z"}
{"level":"info","message":"undefined","timestamp":"2025-09-22T12:13:11.848Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:13:14.942Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:13:14.947Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:13:14.991Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:13:14.992Z"}
{"level":"info","message":"undefined || ","timestamp":"2025-09-22T12:13:14.993Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:13:28.580Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:13:28.585Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:13:28.631Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:13:28.633Z"}
{"level":"info","message":"undefined","timestamp":"2025-09-22T12:13:28.634Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:13:33.197Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:13:33.202Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:13:33.241Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:13:33.243Z"}
{"level":"info","message":"undefined","timestamp":"2025-09-22T12:13:33.244Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:13:56.247Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:13:56.252Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:13:56.292Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:13:56.294Z"}
{"level":"info","message":"undefined","timestamp":"2025-09-22T12:13:56.294Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:15:05.368Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:15:05.374Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:15:05.413Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:15:05.414Z"}
{"level":"info","message":"http://localhost:{PORT}","timestamp":"2025-09-22T12:15:05.414Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:16:53.631Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:16:57.299Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:17:01.198Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:17:06.929Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:17:11.993Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:17:21.121Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:17:21.126Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:17:21.165Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:17:21.167Z"}
{"level":"info","message":"http://localhost:4000","timestamp":"2025-09-22T12:17:21.168Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:17:25.836Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:17:25.842Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:17:25.909Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:17:25.911Z"}
{"level":"info","message":"http://localhost:4000","timestamp":"2025-09-22T12:17:25.911Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:17:32.960Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:17:32.968Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:17:33.018Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:17:33.020Z"}
{"level":"info","message":"http://localhost:4000","timestamp":"2025-09-22T12:17:33.025Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:17:43.249Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:17:43.257Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:17:43.309Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:17:43.312Z"}
{"level":"info","message":"http://localhost:3000","timestamp":"2025-09-22T12:17:43.312Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:17:53.431Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:17:53.436Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:17:53.475Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:17:53.476Z"}
{"level":"info","message":"http://localhost:3000","timestamp":"2025-09-22T12:17:53.477Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:18:28.733Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:18:28.738Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:18:28.785Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:18:28.787Z"}
{"level":"info","message":"http://localhost:3000","timestamp":"2025-09-22T12:18:28.788Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:18:48.334Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:18:48.339Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:18:48.378Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:18:48.379Z"}
{"level":"info","message":"http://localhost:3000","timestamp":"2025-09-22T12:18:48.380Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:19:29.498Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:19:29.504Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:19:29.544Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:19:29.545Z"}
{"level":"info","message":"http://localhost:3000","timestamp":"2025-09-22T12:19:29.546Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:19:46.083Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:19:46.089Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:19:46.137Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:19:46.139Z"}
{"level":"info","message":"http://localhost:4000","timestamp":"2025-09-22T12:19:46.146Z"}
{"level":"info","message":"Redis conneted","timestamp":"2025-09-22T12:19:58.409Z"}
{"level":"info","message":"Database connected","timestamp":"2025-09-22T12:19:58.414Z"}
{"level":"info","message":"Cron job started: Sending request to http://localhost:3000 every 10 minutes","timestamp":"2025-09-22T12:19:58.452Z"}
{"level":"info","message":"Server started at port","timestamp":"2025-09-22T12:19:58.454Z"}
{"level":"info","message":"http://localhost:3000","timestamp":"2025-09-22T12:19:58.455Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T12:20:00.099Z"}
{"level":"info","message":"Cron job success: http://localhost:3000 - Status: 200","timestamp":"2025-09-22T12:30:00.038Z"}
